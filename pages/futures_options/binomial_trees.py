# -*- coding: utf-8 -*-
"""
Created on Tue Apr 19 20:20:33 2022

@author: kerry
"""

import dash_bootstrap_components as dbc
from dash import dcc, html, Output, Input, callback
from pages.futures_options.binomial_trees_figtbl import figtbl
from pages.formatting import Slider, Layout, text_style, lightblue

title = "Binomial trees"
runtitle = None
chapter = "Futures and Options"
chapter_url = "futures-options"
urls = None
text = """ 
    A binomial tree is generated for an underlying asset based on the initial price, number of periods, and the return
    in the up state.  Letting $$u$$ denote the rate of return in the up state, the rate of return $$d$$ in 
    the down state is 
    defined by $$(1+u)(1+d) = 1$$.  A binomial tree is also generated for an option, assuming the underlying asset
    does not pay dividends prior to the option maturity.  Note that the ordering of values on the option plot y-axis
    is reversed for puts (put values are higher when the underlying price is lower). 
    
    The tree for the option is 
    generated by first computing the intrinsic value at each of the nodes at maturity, then iteratively working
    towards the beginning of the tree by computing at each node (i) the discounted expected value of the
    successor nodes for European options, and (ii) the maximum of (i) and the intrinsic value (value of
    immediate exercise) for American options.  Discounting is at the risk-free rate, and expected values are 
    computed using the 'risk-neutral probabilities.'  The risk-neutral probabilities are the probabilities such that
    the expected return of the underlying asset is the risk-free rate.  This means that the risk-neutral probability
    $p$ of the up state is the solution of the equation $p(1+u) + (1-p)(1+d) = 1+r$, which implies that
    $p = (r-d)/(u-d)$, where $r$ is the risk-free rate.
    """

name = "binomial-trees"

inputs = [name + "input" + str(i) for i in range(6)]

drop = dcc.Dropdown(
    ["European call", "American call", "European put", "American put"],
    value="European call",
    id=inputs[0],
    style={"backgroundColor": lightblue}
)
drop = html.Div([dbc.Label("Type of option", html_for=inputs[0]), drop])

slider1 = Slider(
    "Initial price of underlying",
    mn=0,
    mx=100,
    step=5,
    value=50,
    tick=25,
    name=inputs[1],
    kind="dol",
)
slider2 = Slider(
    "Strike price of option",
    mn=0,
    mx=100,
    step=5,
    value=50,
    tick=25,
    name=inputs[2],
    kind="dol",
)
slider3 = Slider(
    "Risk-free rate per period",
    mn=0,
    mx=5,
    step=1,
    value=1,
    tick=1,
    name=inputs[3],
    kind="pct",
)
slider4 = Slider(
    "Return in up state",
    mn=5,
    mx=20,
    step=1,
    value=10,
    tick=5,
    name=inputs[4],
    kind="pct",
)
slider5 = Slider(
    "Number of periods",
    mn=1,
    mx=10,
    step=1,
    value=3,
    tick=None,
    name=inputs[5],
    kind="tip",
)

graph1 = dcc.Graph(id=name + "fig1")
graph2 = dcc.Graph(id=name + "fig2")

string1 = html.Div(id=name + "string1")
string2 = html.Div(id=name + "string2", style=text_style)
string4 = html.Div("Risk-neutral probability of up state:")
string3 = html.Div(id=name + "string3", style=text_style)
string1 = dbc.Col(string1, md=3)
string2 = dbc.Col(string2, md=3)
string3 = dbc.Col(string3, md=3)
string4 = dbc.Col(string4, md=3)
row = dbc.Row([string4, string3, string1, string2])

col1 = dbc.Col([drop, slider5], md=4)
col2 = dbc.Col([slider1, slider2], md=4)
col3 = dbc.Col([slider3, slider4], md=4)
row1 = dbc.Row([col1, col2, col3], align="center")

col1 = dbc.Col(graph1, md=6)
col2 = dbc.Col(graph2, md=6)
row2 = dbc.Row([col1, col2], align="center")

body = html.Div([row1, html.Br(), row, html.Br(), row2])

layout = Layout(
    title=title,
    runtitle=runtitle,
    chapter=chapter,
    chapter_url=chapter_url,
    urls=urls,
    text=text,
    body=body,
)
outputs = [Output(name + f, "figure") for f in ["fig1", "fig2"]] + [
    Output(name + s, "children") for s in ["string1", "string2", "string3"]
]
inputs = [Input(i, "value") for i in inputs]
lst = outputs + inputs


@callback(*lst)
def call(*args):
    return figtbl(*args)
