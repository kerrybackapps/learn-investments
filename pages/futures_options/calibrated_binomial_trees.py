# -*- coding: utf-8 -*-
"""
Created on Tue Apr 19 20:20:33 2022

@author: kerry
"""

import dash_bootstrap_components as dbc
from dash import dcc, html, Output, Input, callback
from pages.futures_options.calibrated_binomial_trees_figtbl import figtbl
from pages.formatting import Slider, Layout, text_style, lightblue

title = "Calibrated binomial trees"
runtitle = None
chapter = "Futures and Options"
chapter_url = "futures-options"
urls = None
text = """ 
    A binomial tree is generated for an underlying asset based on the initial price, number of periods $$N$$, the time
    horizon $$T$$ (years to maturity), and the volatility $$\\sigma$$.  The capital gain rate $$u$$ in the up state each 
    period is defined as 
    $$u = e^{\\sigma \\sqrt{T/N}}-1$$, and the capital gain rate $$d$$ in the down state is defined by
    $$(1+u)(1+d) = 1$$.  A binomial tree is also generated for an option, using the underlying asset
    parameters and the risk-free rate, dividend yield, and strike price.  Note that the ordering of values 
    on the option plot y-axis
    is reversed for puts (put values are higher when the underlying price is lower). 
    
    The tree for the option is 
    generated by first computing the intrinsic value at each of the nodes at maturity, then iteratively working
    towards the beginning of the tree by computing at each nodel (i) the discounted expected value of the
    successor nodes for European options, and (ii) the maximum of (i) and the intrinsic value (value of
    immediate exercise) for American options.  The sliders should be used to input the continuously
    compounded interest rate and dividend yield.  The single period discount factor is 
    computed as $$e^{-rT/N}$$.  Expected values are 
    computed using the 'risk-neutral probabilities,'  which are the probabilities such that the expected return of
    the underlying asset is the risk-free rate.  This means that the risk-neutral probability $$p$$ of the 
    up state is the solution to
    the equation $$p(1+u)e^{qT/N} + (1-p)(1+d)e^{qT/N} = e^{rT/N}$$, which implies that
    $$p = (e^{(r-q)T/N} -1 - d)/(u-d)$$.
    
    
    """
name = "calibrated-binomial-trees"

inputs = [name + "input" + str(i) for i in range(8)]

drop = dcc.Dropdown(
    ["European call", "American call", "European put", "American put"],
    value="European call",
    id=inputs[0],
    style={"backgroundColor": lightblue}
)
drop = html.Div([dbc.Label("Type of option", html_for=inputs[0]), drop])

slider1 = Slider(
    "Initial price of underlying",
    mn=0,
    mx=200,
    step=1,
    value=50,
    tick=50,
    name=inputs[1],
    kind="dol",
)
slider2 = Slider(
    "Strike price of option",
    mn=0,
    mx=200,
    step=5,
    value=50,
    tick=50,
    name=inputs[2],
    kind="dol",
)
slider3 = Slider(
    "Risk-free rate per year",
    mn=0,
    mx=8,
    step=0.25,
    value=1,
    tick=2,
    name=inputs[3],
    kind="pct",
)
slider4 = Slider(
    "Dividend yield per year",
    mn=0,
    mx=8,
    step=.1,
    value=2,
    tick=2,
    name=inputs[4],
    kind="pct",
)
slider5 = Slider(
    "Volatility per year",
    mn=10,
    mx=70,
    step=1,
    value=30,
    tick=20,
    name=inputs[5],
    kind="pct",
)
slider6 = Slider(
    "Years to maturity",
    mn=0,
    mx=2,
    step=0.1,
    value=1,
    tick=None,
    name=inputs[6],
    kind="tip",
)
slider7 = Slider(
    "Number of periods",
    mn=1,
    mx=20,
    step=1,
    value=10,
    tick=None,
    name=inputs[7],
    kind="tip",
)

graph1 = dcc.Graph(id=name + "fig1")
graph2 = dcc.Graph(id=name + "fig2")

string1 = html.Div(id=name + "string1")
string2 = html.Div(id=name + "string2", style=text_style)
string4 = html.Div("Risk-neutral probability of up state:")
string3 = html.Div(id=name + "string3", style=text_style)
string1 = dbc.Col(string1, xs=12, sm=6, md=3, lg=3, className="mb-2")
string2 = dbc.Col(string2, xs=12, sm=6, md=3, lg=3, className="mb-2")
string3 = dbc.Col(string3, xs=12, sm=6, md=3, lg=3, className="mb-2")
string4 = dbc.Col(string4, xs=12, sm=6, md=3, lg=3, className="mb-2")
row = dbc.Row([string4, string3, string1, string2], className="gx-1")

col1 = dbc.Col([drop, html.Br(), slider7], xs=12, sm=6, md=3, lg=3, className="mb-2")
col2 = dbc.Col([slider1, slider2], xs=12, sm=6, md=3, lg=3, className="mb-2")
col3 = dbc.Col([slider3, slider4], xs=12, sm=6, md=3, lg=3, className="mb-2")
col4 = dbc.Col([slider5, slider6], xs=12, sm=6, md=3, lg=3, className="mb-2")
row1 = dbc.Row([col1, col2, col3, col4], align="center", className="gx-1")

left = dbc.Col(graph1, xs=12, sm=12, md=6, lg=6, className="mb-2")
right = dbc.Col(graph2, xs=12, sm=12, md=6, lg=6, className="mb-2")
row2 = dbc.Row([left, right], align="center", className="gx-1")
body = dbc.Container([row1, html.Br(), row, html.Br(), row2], fluid=True, className="px-1")

layout = Layout(
    title=title,
    runtitle=runtitle,
    chapter=chapter,
    chapter_url=chapter_url,
    urls=urls,
    text=text,
    body=body,
)
outputs = [Output(name + f, "figure") for f in ["fig1", "fig2"]] + [
    Output(name + s, "children") for s in ["string1", "string2", "string3"]
]
inputs = [Input(i, "value") for i in inputs]
lst = outputs + inputs


@callback(*lst)
def call(*args):
    return figtbl(*args)
